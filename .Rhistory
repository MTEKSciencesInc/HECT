if (response.type == 'absolute') {
ysd = ifelse(length(y) == 1, 1, sd(y))
post0 = post_Gauss(yb, xb, post0, ysd)
theta_new = apply(post0, 1, function(x) rnorm(N, x[1], x[2]))
}
#theta_new[,which(addarmlater>j)] = -Inf
theta = abind(theta, theta_new, along = 3)
if (compCon == F) {
check[,which(prand>0)] = t(apply(theta[,which(prand>0),j+1], 1, sup_check))
check[,which(prand==0)] = 0
psup_out = abind(psup_out, apply(check, 2, mean), along = 2)
psup_out[which(addarmlater>j), j+1] = 0
if (length(y) < burn) {
psup = abind(psup, psup[,j], along = 2)
} else psup = abind(psup, apply(check, 2, mean), along = 2)
ll = NULL
if (length(which(psup[,j+1] < lower))>0) {
ll = which(psup[,j+1] < lower)
}
if (!is.null(ll)) {
fut.stop = c(fut.stop, ll[addarmlater[ll]<j])
}
if (!is.null(fut.stop)) {
psup[fut.stop,j+1] = 0
if (platf == T) addarmlater[nt] = j
}
ntj = length(which(addarmlater<=j & psup[,j+1]>0))
if (sum(addarmlater==j)>0) ntj = ntj + sum(addarmlater==j)
prand = rep(0, nt)
if (adapt == T & length(y)>=burn)  {
prand[which(addarmlater<=j & psup[,j+1]>0)] = ((ntj - 1)/ntj)*sqrt(psup[which(addarmlater<=j & psup[,j+1]>0),j+1])
} else prand[which(addarmlater<=j & psup[,j+1]>0)] = 1/ntj
prand[which(addarmlater==j)] = 1/ntj
} else {
mat = apply(theta[,which(prand>0),j+1], 1, con_sup_check)
if (is.null(dim(mat))) mat = matrix(mat, N, length(which(prand>0)) - 1) else mat = t(mat)
check[,which(prand>0)] = cbind(rep(0, N), mat)
check[,which(prand==0)] = 0
psup_out = abind(psup_out, apply(check, 2, mean), along = 2)
psup_out[which(addarmlater>j), j+1] = 0
if (length(y) < burn) {
psup = abind(psup, psup[,j], along = 2)
} else psup = abind(psup, apply(check, 2, mean), along = 2)
fmat = apply(theta[,which(prand>0),j+1], 1, con_fut_check, MID = MID)
if (is.null(dim(fmat))) fmat = matrix(fmat, N, length(which(prand>0)) - 1) else fmat = t(fmat)
fcheck[,which(prand>0)] = cbind(rep(0, N), fmat)
fcheck[,which(prand==0)] = 0
pfut = apply(fcheck, 2, mean)
pfut[which(addarmlater>j)] = 0
ff = NULL
if (length(which(pfut > uppfut))>0) ff = which(pfut > uppfut)
if (!is.null(ff)) {
fut.stop = c(fut.stop, ff[addarmlater[ff]<j])
}
if (!is.null(fut.stop)) {
psup[fut.stop,j+1] = 0
if (platf == T) addarmlater[nt] = j
}
psup_out[,1] = c(0,rep(1/(nt0-1), (nt - 1)))
psup_out[which(addarmlater>0),1] = 0
ntj = length(which(addarmlater<=j & psup[,j+1]>0)) + 1
if (sum(addarmlater==j)>0) ntj = ntj + sum(addarmlater==j)
prand = rep(0, nt)
prand[which(addarmlater<=j & psup[,j+1]>0)]  = 1
prand[1] = 1
prand[which(addarmlater==j)] = 1
}
fut.stop
ll
j = j + 1
# if (is.function(updateProgress)) {
#   text <- paste0("updating results based on batch/patient:", j)
#   updateProgress(detail = text)
# }
xb = rmultinom(nb, 1, prob = prand)
xb0 = xb
for (k in 1:nb) {
xb0[which(xb0[,k] == 1), k] = rbinom(1, 1, padhere[which(xb0[,k] == 1)])
}
if (response.type == 'rate') {
yb = apply(t(xb0)%*%theta0, 1, function(z) rbinom(1, 1, prob = z))
}
if (response.type == 'count') {
yb = apply(t(xb0)%*%theta0, 1, function(z) rpois(1, exp(z)))
}
if (response.type == 'absolute') {
yb = apply(t(xb0)%*%theta0, 1, function(z) rnorm(1, z))
}
x = abind(x, xb, along = 2)
x0 = abind(x0, xb0, along = 2)
y = c(y, yb)
if ((response.type == 'rate' | response.type == 'count') & conjugate_prior != T) {
smc_out = SMC_step(theta[,,j], x = xb0, y = yb, N = N, response.type)
theta_new = smc_out$theta
qt = apply(theta_new, 2, sd)/3
Gibbs_out = apply(theta_new, 1, Gibbs, y = y, x = x[,-1], qt = qt,
response.type = response.type, ng)
theta_new = t(sapply(Gibbs_out, function(l) return(l$theta)))
}
if (response.type == 'rate' & conjugate_prior == T) {
post0 = post_beta(yb, xb, post0)
p_new = apply(post0, 1, function(x) rbeta(N, x[1], x[2]))
theta_new = - log((1 - p_new) / p_new)
}
if (response.type == 'count' & conjugate_prior == T) {
post0 = post_gamma(yb, xb, post0)
lambda_new = apply(post0, 1, function(x) rgamma(N, x[1], x[2]))
theta_new = log(lambda_new)
}
if (response.type == 'absolute') {
ysd = ifelse(length(y) == 1, 1, sd(y))
post0 = post_Gauss(yb, xb, post0, ysd)
theta_new = apply(post0, 1, function(x) rnorm(N, x[1], x[2]))
}
#theta_new[,which(addarmlater>j)] = -Inf
theta = abind(theta, theta_new, along = 3)
if (compCon == F) {
check[,which(prand>0)] = t(apply(theta[,which(prand>0),j+1], 1, sup_check))
check[,which(prand==0)] = 0
psup_out = abind(psup_out, apply(check, 2, mean), along = 2)
psup_out[which(addarmlater>j), j+1] = 0
if (length(y) < burn) {
psup = abind(psup, psup[,j], along = 2)
} else psup = abind(psup, apply(check, 2, mean), along = 2)
ll = NULL
if (length(which(psup[,j+1] < lower))>0) {
ll = which(psup[,j+1] < lower)
}
if (!is.null(ll)) {
fut.stop = c(fut.stop, ll[addarmlater[ll]<j])
}
if (!is.null(fut.stop)) {
psup[fut.stop,j+1] = 0
if (platf == T) addarmlater[nt] = j
}
ntj = length(which(addarmlater<=j & psup[,j+1]>0))
if (sum(addarmlater==j)>0) ntj = ntj + sum(addarmlater==j)
prand = rep(0, nt)
if (adapt == T & length(y)>=burn)  {
prand[which(addarmlater<=j & psup[,j+1]>0)] = ((ntj - 1)/ntj)*sqrt(psup[which(addarmlater<=j & psup[,j+1]>0),j+1])
} else prand[which(addarmlater<=j & psup[,j+1]>0)] = 1/ntj
prand[which(addarmlater==j)] = 1/ntj
} else {
mat = apply(theta[,which(prand>0),j+1], 1, con_sup_check)
if (is.null(dim(mat))) mat = matrix(mat, N, length(which(prand>0)) - 1) else mat = t(mat)
check[,which(prand>0)] = cbind(rep(0, N), mat)
check[,which(prand==0)] = 0
psup_out = abind(psup_out, apply(check, 2, mean), along = 2)
psup_out[which(addarmlater>j), j+1] = 0
if (length(y) < burn) {
psup = abind(psup, psup[,j], along = 2)
} else psup = abind(psup, apply(check, 2, mean), along = 2)
fmat = apply(theta[,which(prand>0),j+1], 1, con_fut_check, MID = MID)
if (is.null(dim(fmat))) fmat = matrix(fmat, N, length(which(prand>0)) - 1) else fmat = t(fmat)
fcheck[,which(prand>0)] = cbind(rep(0, N), fmat)
fcheck[,which(prand==0)] = 0
pfut = apply(fcheck, 2, mean)
pfut[which(addarmlater>j)] = 0
ff = NULL
if (length(which(pfut > uppfut))>0) ff = which(pfut > uppfut)
if (!is.null(ff)) {
fut.stop = c(fut.stop, ff[addarmlater[ff]<j])
}
if (!is.null(fut.stop)) {
psup[fut.stop,j+1] = 0
if (platf == T) addarmlater[nt] = j
}
psup_out[,1] = c(0,rep(1/(nt0-1), (nt - 1)))
psup_out[which(addarmlater>0),1] = 0
ntj = length(which(addarmlater<=j & psup[,j+1]>0)) + 1
if (sum(addarmlater==j)>0) ntj = ntj + sum(addarmlater==j)
prand = rep(0, nt)
prand[which(addarmlater<=j & psup[,j+1]>0)]  = 1
prand[1] = 1
prand[which(addarmlater==j)] = 1
}
ll
fut.stop
psup
j
!is.null(fut.stop)
fut.stop = c()
!is.null(fut.stop)
ll = 4
if (!is.null(ll)) {
fut.stop = c(fut.stop, ll[addarmlater[ll]<j])
}
fut.stop
!is.null(fut.stop)
ll[addarmlater[ll]<j]
!is.null(ll[addarmlater[ll]<j])
ll
if (!is.null(ll[addarmlater[ll]<j])) {
fut.stop = c(fut.stop, ll[addarmlater[ll]<j])
}
!is.null(fut.stop)
fut.stop = c()
if (!is.null(ll[addarmlater[ll]<j])) {
fut.stop = c(fut.stop, ll[addarmlater[ll]<j])
}
!is.null(fut.stop)
fut.stop
fut.stop = c()
fut.stop
!is.null(ll[addarmlater[ll]<j])
j
ll[addarmlater[ll]<j])
ll[addarmlater[ll]<j]
ll
ll[addarmlater[ll]<j]
length(ll[addarmlater[ll]<j])
fut.stop = c()
if (length(which(psup[,j+1] < lower))>0) {
ll = which(psup[,j+1] < lower)
}
if (length(ll[addarmlater[ll]<j]) != 0) {
fut.stop = c(fut.stop, ll[addarmlater[ll]<j])
}
!is.null(fut.stop)
fut.stop
ll
ll = 4
if (length(ll[addarmlater[ll]<j]) != 0) {
fut.stop = c(fut.stop, ll[addarmlater[ll]<j])
}
if (!is.null(fut.stop)) {
psup[fut.stop,j+1] = 0
if (platf == T) addarmlater[nt] = j
}
!is.null(fut.stop)
fut.stop
ll = 4
length(ll[addarmlater[ll]<j]) != 0
fut.stop = c()
if (length(ll[addarmlater[ll]<j]) != 0) {
fut.stop = c(fut.stop, ll[addarmlater[ll]<j])
}
!is.null(fut.stop)
RAR_sim = function(nt, theta0, nb = 1, maxN = 500, N = 1000, upper = 0.975, uppfut = 0.95, lower = .01,
burn = 10*nt, response.type, conjugate_prior = T, padhere = rep(1,nt), adapt = T,
platf = T, compCon = F, MID = 0) {
ng = nb
addarmlater = rep(0, nt)
if (platf == T) addarmlater[nt] = Inf
j = 0
x = array(0, dim = c(nt, 1))
x0 = array(0, dim = c(nt, 1))
y = NULL
theta = array(rnorm(N*nt, 0, 10), dim = c(N, nt, 1))
check = array(0, dim = c(N, nt))
fcheck = array(0, dim = c(N, nt))
if (conjugate_prior != T | response.type == "absolute") post0 = cbind(rep(0, nt), rep(10, nt))
if (conjugate_prior == T & response.type == "rate") {
post0 = cbind(rep(1, nt), rep(1, nt))
p_new = apply(post0, 1, function(x) rbeta(N, x[1], x[2]))
theta = array(- log((1 - p_new) / p_new), dim = c(N, nt, 1))
}
if (conjugate_prior == T & response.type == "count") {
post0 = cbind(rep(.1, nt), rep(.001, nt))
lambda_new = apply(post0, 1, function(x) rgamma(N, x[1], x[2]))
theta = array(log(lambda_new), dim = c(N, nt, 1))
}
psup = array(rep(1/nt, nt), dim = c(nt, 1))
nt0 = length(which(addarmlater == 0))
psup_out = array(rep(1/nt0, nt), dim = c(nt, 1))
psup_out[which(addarmlater>0),1] = 0
prand = rep(1/nt, nt)
prand[which(addarmlater>0)] = 0
fut.stop = NULL
repeat {
j = j + 1
# if (is.function(updateProgress)) {
#   text <- paste0("updating results based on batch/patient:", j)
#   updateProgress(detail = text)
# }
xb = rmultinom(nb, 1, prob = prand)
xb0 = xb
for (k in 1:nb) {
xb0[which(xb0[,k] == 1), k] = rbinom(1, 1, padhere[which(xb0[,k] == 1)])
}
if (response.type == 'rate') {
yb = apply(t(xb0)%*%theta0, 1, function(z) rbinom(1, 1, prob = z))
}
if (response.type == 'count') {
yb = apply(t(xb0)%*%theta0, 1, function(z) rpois(1, exp(z)))
}
if (response.type == 'absolute') {
yb = apply(t(xb0)%*%theta0, 1, function(z) rnorm(1, z))
}
x = abind(x, xb, along = 2)
x0 = abind(x0, xb0, along = 2)
y = c(y, yb)
if ((response.type == 'rate' | response.type == 'count') & conjugate_prior != T) {
smc_out = SMC_step(theta[,,j], x = xb0, y = yb, N = N, response.type)
theta_new = smc_out$theta
qt = apply(theta_new, 2, sd)/3
Gibbs_out = apply(theta_new, 1, Gibbs, y = y, x = x[,-1], qt = qt,
response.type = response.type, ng)
theta_new = t(sapply(Gibbs_out, function(l) return(l$theta)))
}
if (response.type == 'rate' & conjugate_prior == T) {
post0 = post_beta(yb, xb, post0)
p_new = apply(post0, 1, function(x) rbeta(N, x[1], x[2]))
theta_new = - log((1 - p_new) / p_new)
}
if (response.type == 'count' & conjugate_prior == T) {
post0 = post_gamma(yb, xb, post0)
lambda_new = apply(post0, 1, function(x) rgamma(N, x[1], x[2]))
theta_new = log(lambda_new)
}
if (response.type == 'absolute') {
ysd = ifelse(length(y) == 1, 1, sd(y))
post0 = post_Gauss(yb, xb, post0, ysd)
theta_new = apply(post0, 1, function(x) rnorm(N, x[1], x[2]))
}
#theta_new[,which(addarmlater>j)] = -Inf
theta = abind(theta, theta_new, along = 3)
if (compCon == F) {
check[,which(prand>0)] = t(apply(theta[,which(prand>0),j+1], 1, sup_check))
check[,which(prand==0)] = 0
psup_out = abind(psup_out, apply(check, 2, mean), along = 2)
psup_out[which(addarmlater>j), j+1] = 0
if (length(y) < burn) {
psup = abind(psup, psup[,j], along = 2)
} else psup = abind(psup, apply(check, 2, mean), along = 2)
ll = NULL
if (length(which(psup[,j+1] < lower))>0) {
ll = which(psup[,j+1] < lower)
}
if (length(ll[addarmlater[ll]<j]) != 0) {
fut.stop = c(fut.stop, ll[addarmlater[ll]<j])
}
if (!is.null(fut.stop)) {
psup[fut.stop,j+1] = 0
if (platf == T) addarmlater[nt] = j
}
ntj = length(which(addarmlater<=j & psup[,j+1]>0))
if (sum(addarmlater==j)>0) ntj = ntj + sum(addarmlater==j)
prand = rep(0, nt)
if (adapt == T & length(y)>=burn)  {
prand[which(addarmlater<=j & psup[,j+1]>0)] = ((ntj - 1)/ntj)*sqrt(psup[which(addarmlater<=j & psup[,j+1]>0),j+1])
} else prand[which(addarmlater<=j & psup[,j+1]>0)] = 1/ntj
prand[which(addarmlater==j)] = 1/ntj
} else {
mat = apply(theta[,which(prand>0),j+1], 1, con_sup_check)
if (is.null(dim(mat))) mat = matrix(mat, N, length(which(prand>0)) - 1) else mat = t(mat)
check[,which(prand>0)] = cbind(rep(0, N), mat)
check[,which(prand==0)] = 0
psup_out = abind(psup_out, apply(check, 2, mean), along = 2)
psup_out[which(addarmlater>j), j+1] = 0
if (length(y) < burn) {
psup = abind(psup, psup[,j], along = 2)
} else psup = abind(psup, apply(check, 2, mean), along = 2)
fmat = apply(theta[,which(prand>0),j+1], 1, con_fut_check, MID = MID)
if (is.null(dim(fmat))) fmat = matrix(fmat, N, length(which(prand>0)) - 1) else fmat = t(fmat)
fcheck[,which(prand>0)] = cbind(rep(0, N), fmat)
fcheck[,which(prand==0)] = 0
pfut = apply(fcheck, 2, mean)
pfut[which(addarmlater>j)] = 0
ff = NULL
if (length(which(pfut > uppfut))>0) ff = which(pfut > uppfut)
if (!is.null(ff)) {
fut.stop = c(fut.stop, ff[addarmlater[ff]<j])
}
if (!is.null(fut.stop)) {
psup[fut.stop,j+1] = 0
if (platf == T) addarmlater[nt] = j
}
psup_out[,1] = c(0,rep(1/(nt0-1), (nt - 1)))
psup_out[which(addarmlater>0),1] = 0
ntj = length(which(addarmlater<=j & psup[,j+1]>0)) + 1
if (sum(addarmlater==j)>0) ntj = ntj + sum(addarmlater==j)
prand = rep(0, nt)
prand[which(addarmlater<=j & psup[,j+1]>0)]  = 1
prand[1] = 1
prand[which(addarmlater==j)] = 1
}
if (sum(prand>0) <= 1  | max(psup[,j+1]) > upper | length(y) >= maxN) break
}
if (conjugate_prior == T) {
if (response.type == 'absolute') {
p.est = post0[,1]
low = apply(post0, 1, function(z) qnorm(.025, z[1], z[2]))
up = apply(post0, 1, function(z) qnorm(.975, z[1], z[2]))
}
if (response.type == "rate") {
p.est = post0[,1]/apply(post0,1,sum)
low = apply(post0, 1, function(z) qbeta(.025, z[1], z[2]))
up = apply(post0, 1, function(z) qbeta(.975, z[1], z[2]))
}
if (response.type == "count") {
p.est = post0[,1]/post0[,2]
low = apply(post0, 1, function(z) qgamma(.025, z[1], z[2]))
up = apply(post0, 1, function(z) qgamma(.975, z[1], z[2]))
}
est = data.frame(p.est = p.est, low = low, up = up)
} else est = NULL
out = list(psup0 = psup, psup = psup_out, theta = theta, est = est, y = y, x = x[,-1], x0 = x0[,-1])
class(out) = 'trial'
return(out)
}
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE)
runApp()
runApp()
runApp()
runApp()
runApp()
63 - 24
1363 + 24
1363 - 24
1984 - 24
runApp()
setwd("~/Documents/Egnyte/Private/sgolchi/BRATS/HECT")
rsconnect::setAccountInfo(name='mtek',
token='18E19A60DAA18287645F43EEA3763DB4',
secret='ikxNjXk2yenuV/qwx/LlqhzaUKHqIOFPCotQC6zq')
setwd("~/Documents/Egnyte/Private/sgolchi/BRATS")
library(rsconnect)
rsconnect::deployApp('HECT')
shinyapps::deployApp('HECT',account='mtek')
rsconnect::deployApp('HECT',account='mtek')
runApp('HECT')
rsconnect::deployApp('HECT',account='mtek')
setwd("~/Documents/Egnyte/Private/sgolchi/BRATS")
setwd("~/Documents/Egnyte/Private/sgolchi/BRATS")
rsconnect::deployApp('HECT',account='mtek')
rsconnect::setAccountInfo(name='mtek',
token='18E19A60DAA18287645F43EEA3763DB4',
secret='ikxNjXk2yenuV/qwx/LlqhzaUKHqIOFPCotQC6zq')
rsconnect::deployApp('HECT',account='mtek')
rsconnect::deployApp('HECT',account='mtek')
rsconnect::setAccountInfo(name='mtek',
token='18E19A60DAA18287645F43EEA3763DB4',
secret='ikxNjXk2yenuV/qwx/LlqhzaUKHqIOFPCotQC6zq')
setwd("~/Documents/Egnyte/Private/sgolchi/BRATS")
rsconnect::setAccountInfo(name='mtek',
token='18E19A60DAA18287645F43EEA3763DB4',
secret='ikxNjXk2yenuV/qwx/LlqhzaUKHqIOFPCotQC6zq')
rsconnect::deployApp('HECT',account='mtek')
runApp('HECT')
runApp('HECT')
g = T
g
!g
runApp('HECT')
runApp('HECT')
runApp('HECT')
runApp('HECT')
runApp('HECT')
runApp('HECT')
runApp('HECT')
runApp('HECT')
runApp('HECT')
runApp('HECT')
runApp('HECT')
runApp('HECT')
runApp('HECT')
runApp('HECT')
runApp('HECT')
runApp('HECT')
runApp('HECT')
runApp('HECT')
runApp('HECT')
runApp('HECT')
runApp('HECT')
nt = 3; theta0 = c(.15, .05, .35); good.out = T; nb = 100; maxN = 500; N = 1000; upper = 0.975; uppfut = 0.95; lower = .01;
burn = 100; response.type = 'rate'; conjugate_prior = T; padhere = rep(1,3); adapt = F;
platf = T; compCon = F; MID = 0
runApp('HECT')
rsconnect::setAccountInfo(name='mtek',
token='18E19A60DAA18287645F43EEA3763DB4',
secret='ikxNjXk2yenuV/qwx/LlqhzaUKHqIOFPCotQC6zq')
setwd("~/Documents/Egnyte/Private/sgolchi/BRATS")
rsconnect::deployApp('HECT', account = 'mtek')
runApp('HECT')
rsconnect::deployApp('HECT', account = 'mtek')
runApp('HECT')
runApp('HECT')
rsconnect::deployApp('HECT', account = 'mtek')
setwd("/Volumes/sgolchi@mteksciences/Private/sgolchi/Brazil")
load("/Volumes/sgolchi@mteksciences/Private/sgolchi/Brazil/2013_2015_06.RData")
View(data.concat)
length(unique(data.concat$municipality))
nrow(data.concat)
table(data.concat$municipality)
library(dplyr)
data.concat %>% filter(municipality == 'BREJO')
data.concat %>% filter(municipality == 'CANTAGALO')
length(unique(data.concad$code_UF))
length(unique(data.concat$code_UF))
length(unique(data.concat$code_IBGE))
length(unique(data.concat$municipality))
length(unique(data.concat$code_IBGE))*3
nrow(data.concat)
0.49/.5
runApp('~/Documents/Egnyte/Private/sgolchi/BRATS/HECT')
setwd("~/Documents/Egnyte/Private/sgolchi/BRATS/HECT")
runApp()
